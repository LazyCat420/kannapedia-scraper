<!DOCTYPE html>
<html>
<head>
    <title>Cannabis Strain Network</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body { margin: 0; padding: 0; display: flex; font-family: Arial, sans-serif; }
        #sidebar { 
            width: 400px; 
            height: 100vh; 
            overflow-y: auto; 
            padding: 20px; 
            background: #f5f5f5;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }
        #network-container { flex-grow: 1; height: 100vh; }
        .strain-card {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .section { margin: 15px 0; }
        pre { white-space: pre-wrap; font-size: 12px; }
    </style>
</head>
<body>
    <div id="sidebar">
        <input type="text" id="search-input" placeholder="Search strains...">
        <div id="strain-info">Select a strain to view details</div>
    </div>
    <div id="network-container"></div>
    
    <script type="text/javascript">
        // Initialize data
        let nodes, allRelationships;
        try {
            nodes = new vis.DataSet({{NODES_DATA}});
            allRelationships = {{RELATIONSHIPS_DATA}};
        } catch (e) {
            console.error('Error initializing data:', e);
            nodes = new vis.DataSet([]);
            allRelationships = [];
        }
        
        // Create network
        const container = document.getElementById('network-container');
        const data = {
            nodes: nodes,
            edges: new vis.DataSet([])  // Start with empty edges
        };
        
        const options = {
            nodes: {
                shape: 'dot',
                size: 16,
                font: { 
                    size: 14,  // Slightly larger font
                    face: 'arial',
                    color: '#000000',
                    strokeWidth: 3,  // Thicker stroke for better readability
                    strokeColor: '#ffffff'  // White outline around text
                },
                borderWidth: 2,
                shadow: true
            },
            edges: {
                width: 2,
                smooth: { type: 'continuous' },
                color: { opacity: 0.5 }
            },
            layout: {
                improvedLayout: true,
                randomSeed: 42,
                circular: {
                    enabled: true,
                    radius: 800,  // Much larger radius
                    levelDistance: 300  // More distance between levels
                }
            },
            physics: {
                enabled: true,
                stabilization: {
                    enabled: true,
                    iterations: 200,
                    updateInterval: 25
                },
                repulsion: {
                    nodeDistance: 200,  // Minimum distance between nodes
                    centralGravity: 0.1,
                    springLength: 300,
                    springConstant: 0.05,
                    damping: 0.09
                }
            },
            interaction: {
                hover: true,
                tooltipDelay: 200,
                zoomView: true,
                dragView: true,
                hideEdgesOnDrag: true,
                hideEdgesOnZoom: true
            }
        };
        
        // Initialize network
        const network = new vis.Network(container, data, options);
        
        // Disable physics after initial layout
        network.once('stabilizationIterationsDone', function() {
            network.setOptions({ physics: { enabled: false } });
        });
        
        // Add zoom buttons and fit button
        const controls = document.createElement('div');
        controls.style.cssText = `
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        `;
        
        const zoomIn = document.createElement('button');
        zoomIn.textContent = 'âž•';
        zoomIn.onclick = () => network.moveTo({ scale: network.getScale() * 1.2 });
        
        const zoomOut = document.createElement('button');
        zoomOut.textContent = 'âž–';
        zoomOut.onclick = () => network.moveTo({ scale: network.getScale() * 0.8 });
        
        const fitButton = document.createElement('button');
        fitButton.textContent = 'âŸ²';
        fitButton.onclick = () => network.fit({ animation: true });
        
        const physicsButton = document.createElement('button');
        physicsButton.textContent = 'ðŸ”„';
        physicsButton.title = 'Toggle Physics';
        let physicsEnabled = false;
        physicsButton.onclick = () => {
            physicsEnabled = !physicsEnabled;
            network.setOptions({ 
                physics: { 
                    enabled: physicsEnabled,
                    stabilization: {
                        enabled: true,
                        iterations: 100,
                        updateInterval: 25
                    },
                    repulsion: {
                        nodeDistance: 200,
                        centralGravity: 0.1,
                        springLength: 300,
                        springConstant: 0.05,
                        damping: 0.09
                    }
                } 
            });
            physicsButton.style.backgroundColor = physicsEnabled ? '#e6f3ff' : 'white';
        };
        
        [zoomIn, zoomOut, fitButton, physicsButton].forEach(button => {
            button.style.cssText = `
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: none;
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                cursor: pointer;
                font-size: 18px;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: background-color 0.3s ease;
            `;
            controls.appendChild(button);
        });
        
        document.getElementById('network-container').appendChild(controls);
        
        // Keep track of currently shown edges
        let currentEdges = new Set();
        
        // Add this before the network click handler
        const activeNodes = new Set();
        
        // Add this function before the network click handler
        async function scrapeStrain(rsp) {
            if (!rsp) {
                console.error('No RSP number provided');
                return;
            }
            
            try {
                // Show loading state
                document.getElementById('strain-info').innerHTML = `
                    <div class="strain-card">
                        <h2>Scraping Data...</h2>
                        <p>Please wait while we fetch the data for RSP: ${rsp}</p>
                    </div>
                `;
                
                // Call the scraping endpoint
                const response = await fetch(`/scrape/${rsp}`);
                const data = await response.json();
                
                if (data.success) {
                    // Refresh the node data
                    const updatedNode = nodes.get(data.strain_name);
                    if (updatedNode) {
                        nodes.update({
                            id: data.strain_name,
                            complete: true,
                            color: {
                                background: '#2B7CE9',
                                border: '#2B7CE9'
                            }
                        });
                    }
                    
                    // Display the scraped data
                    displayStrainData(data.strain_data, data.strain_name, rsp);
                } else {
                    throw new Error(data.error || 'Failed to scrape data');
                }
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('strain-info').innerHTML = `
                    <div class="strain-card">
                        <h2>Error</h2>
                        <p>Failed to scrape data: ${error.message}</p>
                        <button onclick="scrapeStrain('${rsp}')" class="strain-button">
                            Try Again
                        </button>
                    </div>
                `;
            }
        }
        
        // Handle node clicks
        network.on('click', function(params) {
            if (params.nodes.length > 0) {
                const nodeId = params.nodes[0];
                const node = nodes.get(nodeId);
                
                if (activeNodes.has(nodeId)) {
                    // Remove this node's connections
                    activeNodes.delete(nodeId);
                    // Remove only edges connected to this node
                    const edgesToRemove = [];
                    data.edges.forEach(edge => {
                        if (edge.from === nodeId || edge.to === nodeId) {
                            edgesToRemove.push(edge.id);
                            currentEdges.delete(edge.id);
                        }
                    });
                    data.edges.remove(edgesToRemove);
                } else {
                    // Add this node's connections
                    activeNodes.add(nodeId);
                    // Add edges for the clicked node
                    allRelationships.forEach(rel => {
                        if (rel.from === nodeId || rel.to === nodeId) {
                            if (rel.distance < 0.2) {  // Only show close relationships
                                const edgeId = `${rel.from}-${rel.to}`;
                                if (!currentEdges.has(edgeId)) {
                                    data.edges.add({
                                        id: edgeId,
                                        from: rel.from,
                                        to: rel.to,
                                        value: 1 - rel.distance,
                                        length: rel.distance * 400
                                    });
                                    currentEdges.add(edgeId);
                                }
                            }
                        }
                    });
                }

                // Update node appearance
                nodes.update({
                    id: nodeId,
                    color: {
                        background: activeNodes.has(nodeId) ? '#ff9999' : (node.complete ? '#2B7CE9' : '#97C2FC'),
                        border: activeNodes.has(nodeId) ? '#ff0000' : (node.complete ? '#2B7CE9' : '#97C2FC')
                    }
                });

                // Handle node data display
                if (node.complete) {
                    fetch(`/strain_data/${encodeURIComponent(nodeId)}|${encodeURIComponent(node.rsp)}`)
                        .then(response => response.json())
                        .then(data => {
                            if (data.success) {
                                displayStrainData(data.data, nodeId, node.rsp);
                            }
                        })
                        .catch(error => console.error('Error:', error));
                } else {
                    document.getElementById('strain-info').innerHTML = `
                        <div class="strain-card">
                            <h2>${nodeId}</h2>
                            <p>RSP: ${node.rsp}</p>
                            ${node.rsp ? `
                                <button onclick="scrapeStrain('${node.rsp}')" class="strain-button">
                                    Scrape Data
                                </button>
                            ` : '<p>No RSP number available for this strain</p>'}
                        </div>
                    `;
                }
            } else {
                // Clicking empty space clears all connections
                activeNodes.clear();
                data.edges.clear();
                currentEdges.clear();
                
                // Reset all node colors
                const allNodes = nodes.get();
                allNodes.forEach(node => {
                    nodes.update({
                        id: node.id,
                        color: {
                            background: node.complete ? '#2B7CE9' : '#97C2FC',
                            border: node.complete ? '#2B7CE9' : '#97C2FC'
                        }
                    });
                });
            }
        });
        
        function displayStrainData(data, strain, rsp) {
            const { summary, chemicals, metadata } = data;
            document.getElementById('strain-info').innerHTML = `
                <div class="strain-card">
                    <h2>${strain}</h2>
                    <p><strong>RSP:</strong> ${rsp}</p>
                    
                    <div class="section">
                        <h3>General Information</h3>
                        ${Object.entries(metadata).map(([key, value]) => 
                            `<p><strong>${key}:</strong> ${value}</p>`
                        ).join('')}
                    </div>
                    
                    <div class="section">
                        <h3>Chemical Content</h3>
                        ${chemicals.map(c => 
                            `<p><strong>${c.Name}:</strong> ${c.Value}</p>`
                        ).join('')}
                    </div>
                    
                    <div class="section">
                        <h3>Genetic Information</h3>
                        <pre>${summary}</pre>
                    </div>
                </div>
            `;
        }
        
        // Add search functionality
        document.getElementById('search-input').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const allNodes = nodes.get();
            allNodes.forEach(node => {
                const matches = node.label.toLowerCase().includes(searchTerm);
                nodes.update({
                    id: node.id,
                    opacity: matches ? 1 : 0.2
                });
            });
        });
        
        // Add some CSS for the strain button
        const style = document.createElement('style');
        style.textContent = `
            .strain-button {
                background: #2B7CE9;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                margin-top: 10px;
            }
            .strain-button:hover {
                background: #1f5aa7;
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html> 