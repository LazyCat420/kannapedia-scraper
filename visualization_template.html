<!DOCTYPE html>
<html>
<head>
    <title>Cannabis Strain Network</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body { margin: 0; padding: 0; display: flex; font-family: Arial, sans-serif; }
        #sidebar { 
            width: 400px; 
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #f5f5f5;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }
        #view-tabs {
            padding: 10px;
            background: #f0f0f0;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 10px;
        }
        .tab-button {
            flex: 1;
            padding: 10px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 14px;
            border-radius: 4px;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }
        .tab-button:hover {
            background: rgba(43, 124, 233, 0.1);
        }
        .tab-button.active {
            border-bottom-color: #2B7CE9;
            color: #2B7CE9;
            background: white;
        }
        #content-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        #search-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 20px;
            box-sizing: border-box;
        }
        #main-content {
            flex: 1;
            height: 100vh;
            position: relative;
        }
        #network-container { flex-grow: 1; height: 100vh; }
        .strain-card {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .section { margin: 15px 0; }
        pre { white-space: pre-wrap; font-size: 12px; }
        .tab-button.active {
            border-bottom-color: #2B7CE9;
            color: #2B7CE9;
        }
        
        .view {
            display: none;
            width: 100%;
            height: calc(100vh - 40px);
        }
        
        .view.active {
            display: flex;
        }
        
        #fractal-container {
            width: 100%;
            height: 100%;
            background: white;
        }
    </style>
</head>
<body>
    <div id="views" style="flex: 1; display: flex;">
        <div id="sidebar">
            <div id="view-tabs">
                <button id="network-tab" class="tab-button active">Network View</button>
                <button id="fractal-tab" class="tab-button">Phylogenetic Tree</button>
            </div>
            <div id="content-container">
                <input type="text" id="search-input" placeholder="Search strains...">
                <div id="strain-info">Select a strain to view details</div>
            </div>
        </div>
        <div id="main-content">
            <div id="network-view" class="view active">
                <div id="network-container"></div>
            </div>
            <div id="fractal-view" class="view" style="display: none;">
                <div id="fractal-container"></div>
            </div>
        </div>
    </div>
    
    <script type="text/javascript">
        // Initialize data
        let nodes, allRelationships;
        try {
            nodes = new vis.DataSet({{NODES_DATA}});
            allRelationships = {{RELATIONSHIPS_DATA}};
        } catch (e) {
            console.error('Error initializing data:', e);
            nodes = new vis.DataSet([]);
            allRelationships = [];
        }
        
        // Create network
        const container = document.getElementById('network-container');
        const data = {
            nodes: nodes,
            edges: new vis.DataSet([])  // Start with empty edges
        };
        
        const options = {
            nodes: {
                shape: 'dot',
                size: 16,
                font: { 
                    size: 14,  // Slightly larger font
                    face: 'arial',
                    color: '#000000',
                    strokeWidth: 3,  // Thicker stroke for better readability
                    strokeColor: '#ffffff'  // White outline around text
                },
                borderWidth: 2,
                shadow: true
            },
            edges: {
                width: 2,
                smooth: { type: 'continuous' },
                color: { opacity: 0.5 }
            },
            layout: {
                improvedLayout: true,
                randomSeed: 42,
                circular: {
                    enabled: true,
                    radius: 800,  // Much larger radius
                    levelDistance: 300  // More distance between levels
                }
            },
            physics: {
                enabled: true,
                stabilization: {
                    enabled: true,
                    iterations: 200,
                    updateInterval: 25
                },
                repulsion: {
                    nodeDistance: 200,  // Minimum distance between nodes
                    centralGravity: 0.1,
                    springLength: 300,
                    springConstant: 0.05,
                    damping: 0.09
                }
            },
            interaction: {
                hover: true,
                tooltipDelay: 200,
                zoomView: true,
                dragView: true,
                hideEdgesOnDrag: true,
                hideEdgesOnZoom: true
            }
        };
        
        // Initialize network
        const network = new vis.Network(container, data, options);
        
        // Disable physics after initial layout
        network.once('stabilizationIterationsDone', function() {
            network.setOptions({ physics: { enabled: false } });
        });
        
        // Add zoom buttons and fit button
        const controls = document.createElement('div');
        controls.style.cssText = `
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        `;
        
        const zoomIn = document.createElement('button');
        zoomIn.textContent = 'âž•';
        zoomIn.onclick = () => network.moveTo({ scale: network.getScale() * 1.2 });
        
        const zoomOut = document.createElement('button');
        zoomOut.textContent = 'âž–';
        zoomOut.onclick = () => network.moveTo({ scale: network.getScale() * 0.8 });
        
        const fitButton = document.createElement('button');
        fitButton.textContent = 'âŸ²';
        fitButton.onclick = () => network.fit({ animation: true });
        
        const physicsButton = document.createElement('button');
        physicsButton.textContent = 'ðŸ”„';
        physicsButton.title = 'Toggle Physics';
        let physicsEnabled = false;
        physicsButton.onclick = () => {
            physicsEnabled = !physicsEnabled;
            network.setOptions({ 
                physics: { 
                    enabled: physicsEnabled,
                    stabilization: {
                        enabled: true,
                        iterations: 100,
                        updateInterval: 25
                    },
                    repulsion: {
                        nodeDistance: 200,
                        centralGravity: 0.1,
                        springLength: 300,
                        springConstant: 0.05,
                        damping: 0.09
                    }
                } 
            });
            physicsButton.style.backgroundColor = physicsEnabled ? '#e6f3ff' : 'white';
        };
        
        [zoomIn, zoomOut, fitButton, physicsButton].forEach(button => {
            button.style.cssText = `
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: none;
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                cursor: pointer;
                font-size: 18px;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: background-color 0.3s ease;
            `;
            controls.appendChild(button);
        });
        
        document.getElementById('network-container').appendChild(controls);
        
        // Keep track of currently shown edges
        let currentEdges = new Set();
        
        // Add this before the network click handler
        const activeNodes = new Set();
        
        // Add this function before the network click handler
        async function scrapeStrain(rsp) {
            if (!rsp) {
                console.error('No RSP number provided');
                return;
            }
            
            try {
                // Show loading state
                document.getElementById('strain-info').innerHTML = `
                    <div class="strain-card">
                        <h2>Scraping Data...</h2>
                        <p>Please wait while we fetch the data for RSP: ${rsp}</p>
                    </div>
                `;
                
                // Call the scraping endpoint
                const response = await fetch(`/scrape/${rsp}`);
                const data = await response.json();
                
                if (data.success) {
                    // Refresh the node data
                    const updatedNode = nodes.get(data.strain_name);
                    if (updatedNode) {
                        nodes.update({
                            id: data.strain_name,
                            complete: true,
                            color: {
                                background: '#2B7CE9',
                                border: '#2B7CE9'
                            }
                        });
                    }
                    
                    // Display the scraped data
                    displayStrainData(data.strain_data, data.strain_name, rsp);
                } else {
                    throw new Error(data.error || 'Failed to scrape data');
                }
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('strain-info').innerHTML = `
                    <div class="strain-card">
                        <h2>Error</h2>
                        <p>Failed to scrape data: ${error.message}</p>
                        <button onclick="scrapeStrain('${rsp}')" class="strain-button">
                            Try Again
                        </button>
                    </div>
                `;
            }
        }
        
        // Handle node clicks
        network.on('click', function(params) {
            if (params.nodes.length > 0) {
                const nodeId = params.nodes[0];
                const node = nodes.get(nodeId);
                
                if (activeNodes.has(nodeId)) {
                    // Remove this node's connections
                    activeNodes.delete(nodeId);
                    // Remove only edges connected to this node
                    const edgesToRemove = [];
                    data.edges.forEach(edge => {
                        if (edge.from === nodeId || edge.to === nodeId) {
                            edgesToRemove.push(edge.id);
                            currentEdges.delete(edge.id);
                        }
                    });
                    data.edges.remove(edgesToRemove);
                } else {
                    // Add this node's connections
                    activeNodes.add(nodeId);
                    // Add edges for the clicked node
                    allRelationships.forEach(rel => {
                        if (rel.from === nodeId || rel.to === nodeId) {
                            if (rel.distance < 0.2) {  // Only show close relationships
                                const edgeId = `${rel.from}-${rel.to}`;
                                if (!currentEdges.has(edgeId)) {
                                    data.edges.add({
                                        id: edgeId,
                                        from: rel.from,
                                        to: rel.to,
                                        value: 1 - rel.distance,
                                        length: rel.distance * 400
                                    });
                                    currentEdges.add(edgeId);
                                }
                            }
                        }
                    });
                }

                // Update node appearance
                nodes.update({
                    id: nodeId,
                    color: {
                        background: activeNodes.has(nodeId) ? '#ff9999' : (node.complete ? '#2B7CE9' : '#97C2FC'),
                        border: activeNodes.has(nodeId) ? '#ff0000' : (node.complete ? '#2B7CE9' : '#97C2FC')
                    }
                });

                // Handle node data display
                if (node.complete) {
                    fetch(`/strain_data/${encodeURIComponent(nodeId)}|${encodeURIComponent(node.rsp)}`)
                        .then(response => response.json())
                        .then(data => {
                            if (data.success) {
                                displayStrainData(data.data, nodeId, node.rsp);
                            }
                        })
                        .catch(error => console.error('Error:', error));
                } else {
                    document.getElementById('strain-info').innerHTML = `
                        <div class="strain-card">
                            <h2>${nodeId}</h2>
                            <p>RSP: ${node.rsp}</p>
                            ${node.rsp ? `
                                <button onclick="scrapeStrain('${node.rsp}')" class="strain-button">
                                    Scrape Data
                                </button>
                            ` : '<p>No RSP number available for this strain</p>'}
                        </div>
                    `;
                }
            }
        });
        
        function displayStrainData(data, strain, rsp) {
            const { summary, chemicals, metadata } = data;
            document.getElementById('strain-info').innerHTML = `
                <div class="strain-card">
                    <h2>${strain}</h2>
                    <p><strong>RSP:</strong> ${rsp}</p>
                    
                    <div class="section">
                        <h3>General Information</h3>
                        ${Object.entries(metadata).map(([key, value]) => 
                            `<p><strong>${key}:</strong> ${value}</p>`
                        ).join('')}
                    </div>
                    
                    <div class="section">
                        <h3>Chemical Content</h3>
                        ${chemicals.map(c => 
                            `<p><strong>${c.Name}:</strong> ${c.Value}</p>`
                        ).join('')}
                    </div>
                    
                    <div class="section">
                        <h3>Genetic Information</h3>
                        <pre>${summary}</pre>
                    </div>
                </div>
            `;
        }
        
        // Add search functionality
        document.getElementById('search-input').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const allNodes = nodes.get();
            allNodes.forEach(node => {
                const matches = node.label.toLowerCase().includes(searchTerm);
                nodes.update({
                    id: node.id,
                    opacity: matches ? 1 : 0.2
                });
            });
        });
        
        // Add some CSS for the strain button
        const style = document.createElement('style');
        style.textContent = `
            .strain-button {
                background: #2B7CE9;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                margin-top: 10px;
            }
            .strain-button:hover {
                background: #1f5aa7;
            }
        `;
        document.head.appendChild(style);

        // Add tab switching functionality
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                // Remove active state from all tabs and views
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.view').forEach(v => {
                    v.style.display = 'none';
                    v.classList.remove('active');
                });
                
                // Activate selected tab and view
                button.classList.add('active');
                const viewId = button.id.replace('-tab', '-view');
                const view = document.getElementById(viewId);
                view.style.display = 'flex';
                view.classList.add('active');
                
                // Render fractal view if selected
                if (viewId === 'fractal-view') {
                    console.log('Active nodes:', Array.from(activeNodes));
                    renderFractalView();
                }
            });
        });

        // Update the tab button text
        document.getElementById('fractal-tab').textContent = 'Phylogenetic Tree';

        // Update the renderFractalView function with phylogenetic tree layout
        function renderFractalView() {
            console.log('Rendering phylogenetic tree');
            const fractalContainer = document.getElementById('fractal-container');
            fractalContainer.innerHTML = '';
            
            if (activeNodes.size === 0) {
                fractalContainer.innerHTML = '<div style="padding: 20px; text-align: center;">Please select nodes in the Network View first</div>';
                return;
            }

            const fractalNodes = new vis.DataSet();
            const fractalEdges = new vis.DataSet();
            const processedNodes = new Set();
            const processedEdges = new Set(); // Track processed edges
            const levelWidth = 400;
            const nodeSpacing = 80;
            
            function addNodeToFractal(nodeId, x, y, level) {
                if (level >= 3 || processedNodes.has(nodeId)) return;
                
                const node = nodes.get(nodeId);
                if (!node) {
                    console.warn(`Node not found for ID: ${nodeId}`);
                    return;
                }
                
                // Create a unique node ID for this level
                const nodeIdWithLevel = `${nodeId}_${level}`;
                if (fractalNodes.get(nodeIdWithLevel)) {
                    console.warn(`Node already exists: ${nodeIdWithLevel}`);
                    return;
                }
                
                processedNodes.add(nodeId);
                
                // Ensure we have a valid label and clean it up
                const nodeLabel = (node.label || node.id || nodeId).replace(/_/g, ' ');
                console.log(`Adding node: ${nodeLabel} at level ${level}`);
                
                // Update node styling with guaranteed label
                fractalNodes.add({
                    id: nodeIdWithLevel,
                    label: nodeLabel,
                    x: x,
                    y: y,
                    level: level,
                    color: {
                        background: level === 0 ? '#ff9999' : '#97C2FC',
                        border: level === 0 ? '#ff0000' : '#2B7CE9',
                        highlight: {
                            background: level === 0 ? '#ffcccc' : '#b3d1ff',
                            border: level === 0 ? '#ff3333' : '#4d88ff'
                        }
                    },
                    size: 30 - (level * 5), // Slightly larger nodes
                    font: {
                        size: Math.max(12, 18 - (level * 2)), // Ensure minimum font size of 12
                        face: 'arial',
                        color: '#000000',
                        strokeWidth: 2,
                        strokeColor: '#ffffff',
                        vadjust: -8 // Adjust label position
                    },
                    title: `${nodeLabel}<br>Level: ${level}<br>Genetic Distance: ${level === 0 ? '0.000' : 'See edge tooltip'}`
                });

                // Filter and sort relationships with distance threshold
                const relationships = allRelationships
                    .filter(rel => {
                        const isConnected = (rel.from === nodeId || rel.to === nodeId);
                        const hasValidNodes = nodes.get(rel.from) && nodes.get(rel.to);
                        const withinDistance = rel.distance < 0.2; // Only show closer relationships
                        return isConnected && hasValidNodes && withinDistance;
                    })
                    .sort((a, b) => a.distance - b.distance)
                    .slice(0, 6);

                console.log(`Found ${relationships.length} valid relationships for ${nodeLabel}`);

                const totalHeight = (relationships.length - 1) * nodeSpacing;
                const startY = y - totalHeight / 2;

                relationships.forEach((rel, index) => {
                    const childId = rel.from === nodeId ? rel.to : rel.from;
                    if (!processedNodes.has(childId)) {
                        const childNode = nodes.get(childId);
                        if (!childNode) {
                            console.warn(`Child node not found: ${childId}`);
                            return;
                        }

                        const childY = startY + (index * nodeSpacing);
                        const distanceMultiplier = Math.max(0.5, Math.min(2, rel.distance * 5));
                        const childX = x + (levelWidth * distanceMultiplier);
                        
                        // Create unique elbow ID using all parameters
                        const elbowId = `elbow_${nodeId}_${childId}_${level}_${index}`;
                        
                        // Check if this edge combination has been processed
                        const edgeKey = [nodeId, childId].sort().join('_');
                        if (!processedEdges.has(edgeKey)) {
                            processedEdges.add(edgeKey);
                            
                            const elbowX = x + ((childX - x) * 0.5);
                            
                            // Add invisible elbow node with debugging info
                            fractalNodes.add({
                                id: elbowId,
                                size: 0,
                                color: { opacity: 0 },
                                x: elbowX,
                                y: childY,
                                title: `Elbow node: ${nodeId} -> ${childId}`
                            });

                            // Add edges with more information
                            fractalEdges.add({
                                id: `edge1_${elbowId}`,
                                from: `${nodeId}_${level}`,
                                to: elbowId,
                                width: 3 - (level * 0.5),
                                color: { 
                                    color: '#2B7CE9',
                                    opacity: 0.9 - (level * 0.2)
                                },
                                smooth: false,
                                title: `Genetic Distance: ${rel.distance.toFixed(3)}\nFrom: ${nodes.get(nodeId).label}\nTo: ${childNode.label}`
                            });

                            fractalEdges.add({
                                id: `edge2_${elbowId}`,
                                from: elbowId,
                                to: `${childId}_${level + 1}`,
                                width: 3 - (level * 0.5),
                                color: { 
                                    color: '#2B7CE9',
                                    opacity: 0.9 - (level * 0.2)
                                },
                                smooth: false
                            });

                            addNodeToFractal(childId, childX, childY, level + 1);
                        }
                    }
                });
            }

            // Initialize root nodes
            const rootNodes = Array.from(activeNodes);
            const rootSpacing = 150;
            const totalRootHeight = (rootNodes.length - 1) * rootSpacing;
            const startY = -totalRootHeight / 2;

            rootNodes.forEach((nodeId, index) => {
                const y = startY + (index * rootSpacing);
                addNodeToFractal(nodeId, -levelWidth, y, 0);
            });

            // Create the network with the same configuration as before
            const fractalNetwork = new vis.Network(fractalContainer, {
                nodes: fractalNodes,
                edges: fractalEdges
            }, {
                physics: false,
                layout: {
                    hierarchical: {
                        enabled: false
                    }
                },
                nodes: {
                    shape: 'dot',
                    scaling: {
                        min: 20,
                        max: 30
                    },
                    font: {
                        size: 14,
                        face: 'arial',
                        strokeWidth: 2,
                        strokeColor: '#ffffff'
                    }
                },
                edges: {
                    width: 2,
                    selectionWidth: 3,
                    smooth: false
                },
                interaction: {
                    dragNodes: false,
                    dragView: true,
                    zoomView: true,
                    hover: true,
                    tooltipDelay: 200,
                    multiselect: false
                }
            });

            // Add scale bar
            const scaleBar = document.createElement('div');
            scaleBar.style.cssText = `
                position: absolute;
                bottom: 40px;
                left: 20px;
                background: rgba(255, 255, 255, 0.9);
                padding: 10px;
                border-radius: 4px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                font-size: 12px;
            `;
            scaleBar.innerHTML = `
                <div>Genetic Distance Scale:</div>
                <div style="display: flex; align-items: center; margin-top: 5px;">
                    <div style="border-top: 2px solid #2B7CE9; width: 50px;"></div>
                    <div style="margin-left: 5px;">0.05</div>
                </div>
                <div style="display: flex; align-items: center; margin-top: 5px;">
                    <div style="border-top: 2px solid #2B7CE9; width: 100px;"></div>
                    <div style="margin-left: 5px;">0.10</div>
                </div>
            `;
            fractalContainer.appendChild(scaleBar);

            // Add controls
            const fractalControls = document.createElement('div');
            fractalControls.style.cssText = `
                position: absolute;
                bottom: 20px;
                right: 20px;
                display: flex;
                gap: 10px;
            `;

            const fitButton = document.createElement('button');
            fitButton.textContent = 'âŸ²';
            fitButton.title = 'Fit to View';
            fitButton.onclick = () => fractalNetwork.fit({ animation: true });
            fitButton.style.cssText = `
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: none;
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                cursor: pointer;
                font-size: 18px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            fractalControls.appendChild(fitButton);
            fractalContainer.appendChild(fractalControls);

            // Initial fit to view
            setTimeout(() => fractalNetwork.fit(), 100);
        }
    </script>
</body>
</html> 